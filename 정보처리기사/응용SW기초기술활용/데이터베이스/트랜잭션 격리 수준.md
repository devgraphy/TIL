### Transaction Isolation level

- 트랜잭션에서 일관성이 없는 데이터를 허용하는 수준



### 트랜잭션 격리수준 필요성

- 데이터베이스는 ACID 속성을 바탕으로 트랜잭션이 원자적이면서도 독립적인 수행 하도록한다.
- 이를 위해 Locking 개념이 등장한다.
  - 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하게 막는 것
- 무조건적인 Locking은 많은 트랜잭션이 하나씩 순서대로 처리하게 되므로 DB 성능은 떨어진다.
- 반대로 응답성을 높이기 위해 locking 범위를 줄이면 잘못된 값이 처리될 여지가 있다.
- 그래서 최대한 효율적인 locking 방법이 필요



### 격리수준

격리 수준은 크게 아래의 4개로 나뉜다.

0. Read uncommitted(레벨 0)

   - READ UNCOMMITTED 격리수준에서는 어떤 트랜잭션의 변경내용이 COMMIT이나 ROLLBACK과 상관없이 다른 트랜잭션에서 보여진다.

   - ex. 어떤 사용자가 A라는 데이터를 B로 변경하는 동안 다른 사용자는 아직 완료되지 않은(uncommitted 혹은 dirty)트랜잭션이지만 변경된 데이터인 B를 읽을 수 있다.

   - 이 격리 수준은 아래와 같은 문제가 발생할 수 있다.

     - a 트랜잭션에서 1번 사원의 나이를 27살에서 28살로 변경
     - 아직 커밋하지 않음
     - b 트랜잭션에서 1번 사원의 나이를 조회
     - 28살이 조회됨
       - 이를 `더티 리드(dirty read)`라고 한다.
     - a 트랜잭션에서 문제가 발생해 rollback함
     - b 트랜잭션은 10 사원이 여전히 28살이라 생각하고 로직을 수행함

   - 이런 식으로 `데이터 정합성`에 문제가 많으므로, RDBMS에서는 격리수준으로 인정하지도 않는다.

   - 발생하는 문제:dirty read, non-repeatable read, phantom read

     - `dirty read`: 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할때 발생

     

1. Read committed(레벨 1)

   - 어떤 트랜잭션의 변경 내용이 commit 되어야만 다른 트랜잭션에서 조회할 수 있다.

   - 오라클 DBMS에서 기본으로 사용하고 있고, 온라인 서비스에서 가장 많이 선택되는 격리수준이다.

   - 발생하는 문제:

     - `non-repeatable read`:  한 트랜잭션 내에서 같은 쿼리를 두번 수행 할 때 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비일관성이 발생하는 것을 말함

     - - 1) 트랜잭션 A 에서 값을 읽는다. select gender, name from user where seq = 1;

           result : M pyo

         2) 트랜잭션 B 에서 값을 넣는다. update user set gender = 'W' where seq = 1;

         3) 트랜잭션 B 에서 commit 한다.

         4) 트랜잭션 A 에서 값을 읽는다. select gender, name from user where seq = 1;

           result : W pyo

           남자였던 pyo 가 여자가 되었다. 위처럼 반복해서 동일한 데이터를 읽을 경우 상이한 결과가 나온다.

     - phantom read

   - ex. 여러 트랜잭션에서 입금/출금 처리가 계속 진행되는 트랜잭션이 있다. 오늘의 입금 총합을 보여주는 트랜잭션이 있다면, 총합을 계산하는 select 쿼리는 실행될 때마다 다른 결과값을 가져올 것이다.

2. Repeatable Read(레벨 2)

   - 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준이다.

   - MySQL DBMS에서 기본으로 사용하고 있고, 이 격리수준에서는 `non-repeatable read`부정합이 발생하지 않는다.

   - 트랜잭션마다 트랜잭션 id를 부여하여 트랜잭션 id보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.

   - 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장한다.

   - 발생하는 문제:phantom read

     - 1) 트랜잭션 A 에서 범위(range) 기준으로 값을 읽는다.

       2) 트랜잭션 B 에서 1)에 포함되는 값을 넣는다.

       3) 트랜잭션 B 에서 commit 한다.

       4) 트랜잭션 A 에서 범위(range) 기준으로 값을 읽는다.

         result : 1)에서 읽히지 않은 값이 결과로 나온다 

     - 한 트랜잭션 안에서 일정 범위의 레코드를 두번 이상 읽을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상

       이는 트랜잭션 도중 새로운 레코드가 삽입되는 것을 허용하기 때문에 나타나는 현상임.

3. Serializable(레벨 3)

   - 트랜잭션이 완료될 때 까지 다른 트랜잭션이 해당되는 영역에 대한 수정 및 입력을 할 수 없다.
   - 완벽한 lock을 건 상태





참고 사이트)

- [데이터베이스 격리 수준 : Database Isolation level (tistory.com)](https://developyo.tistory.com/236)
- [트랜잭션 수준 읽기 일관성 - [종료\]코어 오라클 데이터베이스 스터디 - 개발자, DBA가 함께 만들어가는 구루비 지식창고! (gurubee.net)](http://wiki.gurubee.net/pages/viewpage.action?pageId=3900389)