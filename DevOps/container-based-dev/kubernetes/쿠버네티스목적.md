# 지금까지 해온 것들 정리(2/22 기준)

*궁극적으로 kubernetes 사용하는 것!*

*EC2에서 사용할 수 있는 서비스 위주로 다뤄 봄*

*AWS에서 제공하는 Elastic Beanstalk으로 AWS의 서비스를 모아 자동화하는 서비스를 이용할 수 도 있음* 

*편하긴 하지만 동작원리는 이해해야하기 때문에 Handsonlab을 통해 실습을 한땀한땀 해봄*

- A Guru Cloud Hands On Lab(주 목표: 클라우드 서비스 경험)
  - 리눅스 기반 EC2 인스턴스에 Web server 설치(apache, nginx)
  - 리눅스 기반 EC2 인스턴스에 mariaDB 설치
  - **Load balancer** - Auto scaling 기능
  - **Route53** - DNS 가지고 서비스 요청할 때, 라우팅 서비스 필요한 상황
  - **SNS** - 로그, 알람 서비스
  - **S3** - 파일 업로드, 다운로드
  - **Lambda** - functional 기능

 

# 목표

- devops -> container -> docker -> kubernetes로 이어지는 기술의 니즈와 목적을 안다.

  

# 쿠버네티스가 필요한 이유

## 24/7 서비스를 제공하고 싶은데...

현대 웹 서비스에서는 유저들은 애플리케이션이 언제든지 계속 운영되기를 바라고 개발자는 하루에도 여러번 새로운 버전의 애플리케이션을 배포하기를 바란다.

컨테이너화(Containerization)는 패키지 소프트웨어가 이러한 목표를 달성할 수 있도록 지원하며 downtime 없이 애플리케이션을 출시하고 업데이트할 수 있도록 해준다.

쿠버네티스는 컨테이너화된 애플리케이션이 원하는 장소와 시간에 실행되도록 하고 작업에 필요한 리소스와 도구를 찾도록 도와준다.



## 도커는 그러한 기능들을 제공 해주지 못하는데...

컨테이너는 애플리케이션을 포장하고 실행하는 좋은 방법이다. 프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야한다. 예를 들어 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야한다. 이 문제를 시스템에 의해 처리한다면 더 쉽지 않을까?

그것이 쿠버네티스가 필요한 이유이다! **쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공한다.** 애플리케이션의 확장과 장애 조치를 처리하고, 배포 패턴 등을 제공한다. 예를 들어, 쿠버네티스는 시스템의 카나리아 배포를 쉽게 관리 할 수 있다.

docker compose는 tier별로 layer에 해당되는 컨테이너들을 배치할 수는 있다. 그러나 그러한 컨테이너들의 오토 스케일링, FTS, 로드밸런싱에 대한 기능은 제공할 순 없었다. 그래서 그러한 기능을 제공해주는 kubernetes가 나오게 되었다.

*For example*

>이전에 dockerfile을 통해 webserver로 nginx를 pull하고 database로는 Redis를 docker compose로 컨테이너 생성해보았다.
>
>이때 Redis를 docker compose로 구성하는 이유는 커스터마이징할 게 없었기 때문이라고 한다.





# 쿠버네티스는 다음을 제공한다.

- **서비스 디스커버리와 로드 밸런싱** 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.
- **스토리지 오케스트레이션** 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있다.
- **자동화된 롤아웃과 롤백** 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.
- **자동화된 빈 패킹(bin packing)** 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.
- **자동화된 복구(self-healing)** 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.
- **시크릿과 구성 관리** 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리 할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트 할 수 있다.



